{
  "aws_secretsmanager": {
    "description": "Secrets can be read from the [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/) and used within your template as locals.\n\nWhen key is not set (`null` or empty: `\"\"`) then `aws_secretsmanager` returns the first secret key stored in secret `name`.\n\nYou can either use this function in a `locals` block or directly inline where you want to use the value.",
    "signature": "aws_secretsmanager(name, key)",
    "type": "contextual",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/contextual/aws_secretsmanager"
  },
  "consul_key": {
    "description": "[Consul](https://www.consul.io) keys can be used within your template using the `consul_key` function.\n\nYou can either use this function in a locals block or directly inline where you want to use the value.",
    "signature": "consul_key(key_path)",
    "type": "contextual",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/contextual/consul"
  },
  "env": {
    "description": "`env` allows you to get the value for an environment variable inside input variables _only_. This is the only function that is callable from a variable block and it can only be used in the default input. `env` cannot be called from other places.",
    "signature": "env(env_var_name)",
    "type": "contextual",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/contextual/env"
  },
  "vault": {
    "description": "Secrets can be read from [Vault](https://www.vaultproject.io/) and used within your template as user variables. the `vault` function is available _only_ within the default value of a user variable, allowing you to default a user variable to a vault secret.",
    "signature": "vault(secret_path, secret_name)",
    "type": "contextual",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/contextual/vault"
  },
  "abs": {
    "description": "`abs` returns the absolute value of the given number. In other words, if the number is zero or positive then it is returned as-is, but if it is negative then it is multiplied by -1 to make it positive before returning it.",
    "signature": "abs(number)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/abs"
  },
  "ceil": {
    "description": "`ceil` returns the closest whole number that is greater than or equal to the given value, which may be a fraction.",
    "signature": "ceil(number)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/ceil"
  },
  "floor": {
    "description": "`floor` returns the closest whole number that is less than or equal to the given value, which may be a fraction.",
    "signature": "floor(number)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/floor"
  },
  "log": {
    "description": "`log` returns the logarithm of a given number in a given base.",
    "signature": "log(number, base)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/log"
  },
  "max": {
    "description": "`max` takes one or more numbers and returns the greatest number from the set. If the numbers are in a list or set value, use `...` to expand the collection to individual arguments.",
    "signature": "max(list[number])",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/max"
  },
  "min": {
    "description": "`min` takes one or more numbers and returns the smallest number from the set. If the numbers are in a list or set value, use `...` to expand the collection to individual arguments.",
    "signature": "min(list[number])",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/min"
  },
  "parseint": {
    "description": "`parseint` parses the given string as a representation of an integer in the specified base and returns the resulting number. The base must be between 2 and 62 inclusive.\n\nAll bases use the arabic numerals 0 through 9 first. Bases between 11 and 36 inclusive use case-insensitive latin letters to represent higher unit values. Bases 37 and higher use lowercase latin letters and then uppercase latin letters.\n\nIf the given string contains any non-digit characters or digit characters that are too large for the given base then `parseint` will produce an error.",
    "signature": "parseint(number, base)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/parseint"
  },
  "pow": {
    "description": "`pow` calculates an exponent, by raising its first argument to the power of the second argument.",
    "signature": "pow(number, to_power)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/pow"
  },
  "signum": {
    "description": "`signum` determines the sign of a number, returning a number between -1 and 1 to represent the sign.",
    "signature": "signum(number)",
    "type": "numeric",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/numeric/signum"
  },
  "chomp": {
    "description": "`chomp` removes newline characters at the end of a string.\n\nThis can be useful if, for example, the string was read from a file that has a newline character at the end.",
    "signature": "chomp(string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/chomp"
  },
  "format": {
    "description": "`format` produces a string by formatting a number of other values according to a specification string. It is similar to the `printf` function in C, and other similar functions in other programming languages.",
    "signature": "format(spec, values...)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/format"
  },
  "formatlist": {
    "description": "`formatlist` produces a list of strings by formatting a number of other values according to a specification string. The specification string uses the same syntax as `format`.\n\nThe given values can be a mixture of list and non-list arguments. Any given lists must be the same length, which decides the length of the resulting list.\n\nThe list arguments are iterated together in order by index, while the non-list arguments are used repeatedly for each iteration. The format string is evaluated once per element of the list arguments.",
    "signature": "formatlist(spec, values...)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/formatlist"
  },
  "indent": {
    "description": "`indent` adds a given number of spaces to the beginnings of all but the first line in a given multi-line string. This function is useful for inserting a multi-line string into an already-indented context in another string",
    "signature": "indent(num_spaces, string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/indent"
  },
  "join": {
    "description": "`join` produces a string by concatenating together all elements of a given list of strings with the given delimiter.",
    "signature": "join(separator, list)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/join"
  },
  "lower": {
    "description": "`lower` converts all cased letters in the given string to lowercase. This function uses Unicode's definition of letters and of upper- and lowercase.",
    "signature": "lower(string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/lower"
  },
  "replace": {
    "description": "`replace` searches a given string for another given substring, and replaces each occurrence with a given replacement string.",
    "signature": "replace(string, substring, replacement)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/replace"
  },
  "regex_replace": {
    "description": "`regex_replace` searches a given string for another given substring, and replaces each occurrence with a given replacement string. The substring argument can be a valid regular expression or a string.\n\n`substring` should not be wrapped in forward slashes, it is always treated as a regular expression. The `replacement` string can incorporate captured strings from the input by using an `$n` or `${n}` sequence, where `n` is the index or name of a capture group.",
    "signature": "regex_replace(string, substring, replacement)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/regex_replace"
  },
  "regex": {
    "description": "`regex` applies a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) to a string and returns the matching substrings.\n\nThe return type of `regex` depends on the capture groups, if any, in the pattern:\n- If the pattern has no capture groups at all, the result is a single string covering the substring matched by the pattern as a whole.\n- If the pattern has one or more _unnamed_ capture groups, the result is a list of the captured substrings in the same order as the definition of the capture groups.\n- If the pattern has one or more _named_ capture groups, the result is a map of the captured substrings, using the capture group names as map keys.",
    "signature": "regex(pattern, string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/regex"
  },
  "regexall": {
    "description": "`regexall` applies a [regular expression](https://en.wikipedia.org/wiki/Regular_expression) to a string and returns a list of all matches.\n\n `regexall` is a variant of `regex` and uses the same pattern syntax. For any given input to `regex`, `regexall` returns a list of whatever type `regex` would've returned, with one element per match. That is:\n\n- If the pattern has no capture groups at all, the result is a list of strings.\n- If the pattern has one or more _unnamed_ capture groups, the result is a list of lists.\n- If the pattern has one or more _named_ capture groups, the result is a list of maps.\n\n`regexall` can also be used to test whether a particular string matches a given pattern, by testing whether the length of the resulting list of matches is greater than zero.",
    "signature": "regexall(pattern, string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/regexall"
  },
  "split": {
    "description": "`split` produces a list by dividing a given string at all occurrences of a given separator.",
    "signature": "split(separator, string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/split"
  },
  "strrev": {
    "description": "`strrev` reverses the characters in a string. Note that the characters are treated as _Unicode characters_ (in technical terms, Unicode [grapheme cluster boundaries](https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries) are respected).",
    "signature": "strrev(string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/strrev"
  },
  "substr": {
    "description": "`substr` extracts a substring from a given string by offset and length. The offset and length are both counted in _unicode characters_ rather than bytes.",
    "signature": "substr(string, offset, length)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/substr"
  },
  "title": {
    "description": "`title` converts the first letter of each word in the given string to uppercase.",
    "signature": "title(string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/title"
  },
  "trim": {
    "description": "`trim` removes the specified characters from the start and end of the given string.",
    "signature": "trim(string, what_to_trim)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/trim"
  },
  "trimprefix": {
    "description": "`trimprefix` removes the specified prefix from the start of the given string.",
    "signature": "trimprefix(string, what_to_trim)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/trimprefix"
  },
  "trimsuffix": {
    "description": "`trimsuffix` removes the specified suffix from the end of the given string.",
    "signature": "trimsuffix(string, what_to_trim)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/trimsuffix"
  },
  "trimspace": {
    "description": "`trimspace` removes any space characters from the start and end of the given string.\n\nThis function follows the Unicode definition of \"space\", which includes regular spaces, tabs, newline characters, and various other space-like characters.",
    "signature": "trimspace(string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/trimspace"
  },
  "upper": {
    "description": "`upper` converts all cased letters in the given string to uppercase. This function uses Unicode's definition of letters and of upper- and lowercase.",
    "signature": "upper(string)",
    "type": "string",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/string/upper"
  },
  "chunklist": {
    "description": "`chunklist` splits a single list into fixed-size chunks, returning a list of lists.",
    "signature": "chunklist(list, chunk_size)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/chunklist"
  },
  "coalesce": {
    "description": "`coalesce` takes any number of arguments and returns the first one that isn't null or an empty string. To perform the `coalesce` operation with a list of strings, use the `...` symbol to expand the list as arguments.",
    "signature": "coalesce(values...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/coalesce"
  },
  "coalescelist": {
    "description": "`coalescelist` takes any number of list arguments and returns the first one that isn't empty. To perform the `coalescelist` operation with a list of lists, use the `...` symbol to expand the outer list as arguments.",
    "signature": "coalescelist(lists...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/coalescelist"
  },
  "compact": {
    "description": "`compact` takes a list of strings and returns a new list with any empty string elements removed.",
    "signature": "compact(list[string])",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/compact"
  },
  "concat": {
    "description": "`concat` takes two or more lists and combines them into a single list.",
    "signature": "concat(lists...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/concat"
  },
  "contains": {
    "description": "`contains` determines whether a given list or set contains a given single value as one of its elements.",
    "signature": "contains(list, value)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/contains"
  },
  "distinct": {
    "description": "`distinct` takes a list and returns a new list with any duplicate elements removed.",
    "signature": "distinct(list)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/distinct"
  },
  "element": {
    "description": "`element` retrieves a single element from a list.\n\nThe index is zero-based. This function produces an error if used with an empty list.\n\nUse the built-in index syntax `list[index]` in most cases. Use this function only for special additional \"wrap-around\" behavior.",
    "signature": "element(list, index)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/element"
  },
  "flatten": {
    "description": "`flatten` takes a list and replaces any elements that are lists with a flattened sequence of the list contents.\n\nIf any of the nested lists also contain directly-nested lists, these too are flattened recursively.\n\nIndirectly-nested lists, such as those in maps, are _not_ flattened.",
    "signature": "flatten(list)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/flatten"
  },
  "index": {
    "description": "`index` finds the element index for a given value in a list. The returned index is zero-based. This function produces an error if the given value is not present in the list.",
    "signature": "index(list, value)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/index-fn"
  },
  "keys": {
    "description": "`keys` takes a map and returns a list containing the keys from that map.\n\nThe keys are returned in lexicographical order, ensuring that the result will be identical as long as the keys in the map don't change.",
    "signature": "keys(map)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/keys"
  },
  "length": {
    "description": "`length` determines the length of a given list, map, or string.\n\nIf given a list or map, the result is the number of elements in that collection. If given a string, the result is the number of characters in the string.\n\nWhen given a string, the result is the number of characters, rather than the number of bytes or Unicode sequences that form them.",
    "signature": "length(list | map | string)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/length"
  },
  "lookup": {
    "description": "`lookup` retrieves the value of a single element from a map, given its key. If the given key does not exist, a the given default value is returned instead.",
    "signature": "lookup(map, key, default)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/lookup"
  },
  "merge": {
    "description": "`merge` takes an arbitrary number of maps and returns a single map that contains a merged set of elements from all of the maps.\n\nIf more than one given map defines the same key then the one that is later in the argument sequence takes precedence.",
    "signature": "merge(maps...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/merge"
  },
  "range": {
    "description": "`range` generates a list of numbers using a start value, a limit value, and a step value.\n\nThe `start` and `step` arguments can be omitted, in which case `start` defaults to zero and `step` defaults to either one or negative one depending on whether `limit` is greater than or less than `start`.\n\nThe resulting list is created by starting with the given `start` value and repeatedly adding `step` to it until the result is equal to or beyond `limit`.\n\nThe interpretation of `limit` depends on the direction of `step`: for a positive step, the sequence is complete when the next number is greater than or equal to `limit`. For a negative step, it's complete when less than or equal.",
    "signature": "range(max), range(start, limit), range(start, limit, step)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/range"
  },
  "reverse": {
    "description": "`reverse` takes a sequence and produces a new sequence of the same length with all of the same elements as the given sequence but in reverse order.",
    "signature": "reverse(list)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/reverse"
  },
  "setintersection": {
    "description": "The `setintersection` function takes multiple sets and produces a single set containing only the elements that all of the given sets have in common. In other words, it computes the [intersection](<https://en.wikipedia.org/wiki/Intersection_(set_theory)>) of the sets.\n\nThe given arguments are converted to sets, so the result is also a set and the ordering of the given elements is not preserved.",
    "signature": "setintersection(sets...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/setintersection"
  },
  "setproduct": {
    "description": "The `setproduct` function finds all of the possible combinations of elements from all of the given sets by computing the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product).\n\nThis function is particularly useful for finding the exhaustive set of all combinations of members of multiple sets, such as per-application-per-environment resources.",
    "signature": "setproduct(sets...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/setproduct"
  },
  "setunion": {
    "description": "The `setunion` function takes multiple sets and produces a single set containing the elements from all of the given sets. In other words, it computes the [union](<https://en.wikipedia.org/wiki/Union_(set_theory)>) of the sets.\n\nThe given arguments are converted to sets, so the result is also a set and the ordering of the given elements is not preserved.",
    "signature": "setunion(sets...)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/setunion"
  },
  "slice": {
    "description": "`slice` extracts some consecutive elements from within a list.\n\n`startindex` is inclusive, while `endindex` is exclusive. This function returns an error if either index is outside the bounds of valid indices for the given list.",
    "signature": "slice(list, startindex, endindex)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/slice"
  },
  "sort": {
    "description": "`sort` takes a list of strings and returns a new list with those strings sorted lexicographically.\n\nThe sort is in terms of Unicode codepoints, with higher codepoints appearing after lower ones in the result.",
    "signature": "sort(list[string])",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/sort"
  },
  "values": {
    "description": "`values` takes a map and returns a list containing the values of the elements in that map.\n\nThe values are returned in lexicographical order by their corresponding _keys_, so the values will be returned in the same order as their keys would be returned from `keys`.",
    "signature": "values(map)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/values"
  },
  "zipmap": {
    "description": "`zipmap` constructs a map from a list of keys and a corresponding list of values.\n\nBoth `keyslist` and `valueslist` must be of the same length. `keyslist` must be a list of strings, while `valueslist` can be a list of any type.\n\nEach pair of elements with the same index from the two lists will be used as the key and value of an element in the resulting map. If the same value appears multiple times in `keyslist` then the value with the highest index is used in the resulting map.",
    "signature": "zipmap(keyslist, valueslist)",
    "type": "collection",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/collection/zipmap"
  },
  "base64decode": {
    "description": "`base64decode` takes a string containing a Base64 character sequence and returns the original string.\n\nPacker uses the \"standard\" Base64 alphabet as defined in [RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).\n\nStrings in the Packer language are sequences of unicode characters rather than bytes, so this function will also interpret the resulting bytes as UTF-8. If the bytes after Base64 decoding are _not_ valid UTF-8, this function produces an error.\n\nWhile we do not recommend manipulating large, raw binary data in the Packer language, Base64 encoding is the standard way to represent arbitrary byte sequences, and so resource types that accept or return binary data will use Base64 themselves, which avoids the need to encode or decode it directly in most cases. Various other functions with names containing \"base64\" can generate or manipulate Base64 data directly.",
    "signature": "base64decode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/base64decode"
  },
  "base64encode": {
    "description": "`base64encode` applies Base64 encoding to a string.\n\nPacker uses the \"standard\" Base64 alphabet as defined in [RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).\n\nStrings in the Packer language are sequences of unicode characters rather than bytes, so this function will first encode the characters from the string as UTF-8, and then apply Base64 encoding to the result.\n\nThe Packer language applies Unicode normalization to all strings, and so passing a string through `base64decode` and then `base64encode` may not yield the original result exactly.\n\nWhile we do not recommend manipulating large, raw binary data in the Packer language, Base64 encoding is the standard way to represent arbitrary byte sequences, and so resource types that accept or return binary data will use Base64 themselves, and so this function exists primarily to allow string data to be easily provided to resource types that expect Base64 bytes.",
    "signature": "base64encode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/base64encode"
  },
  "csvdecode": {
    "description": "`csvdecode` decodes a string containing CSV-formatted data and produces a list of maps representing that data.\n\nCSV is _Comma-separated Values_, an encoding format for tabular data. There are many variants of CSV, but this function implements the format defined in [RFC 4180](https://tools.ietf.org/html/rfc4180).\n\nThe first line of the CSV data is interpreted as a \"header\" row: the values given are used as the keys in the resulting maps. Each subsequent line becomes a single map in the resulting list, matching the keys from the header row with the given values by index. All lines in the file must contain the same number of fields, or this function will produce an error.",
    "signature": "csvdecode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/csvdecode"
  },
  "jsondecode": {
    "description": "`jsondecode` interprets a given string as JSON, returning a representation of the result of decoding that string.\n\nThe JSON encoding is defined in [RFC 7159](https://tools.ietf.org/html/rfc7159).",
    "signature": "jsondecode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/jsondecode"
  },
  "jsonencode": {
    "description": "`jsonencode` encodes a given value to a string using JSON syntax.\n\nThe JSON encoding is defined in [RFC 7159](https://tools.ietf.org/html/rfc7159).",
    "signature": "jsonencode(value)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/jsonencode"
  },
  "urlencode": {
    "description": "`urlencode` applies URL encoding to a given string.\n\nThis function identifies characters in the given string that would have a special meaning when included as a query string argument in a URL and escapes them using [RFC 3986 \"percent encoding\"](https://tools.ietf.org/html/rfc3986#section-2.1).\n\nThe exact set of characters escaped may change over time, but the result is guaranteed to be interpolatable into a query string argument without inadvertently introducing additional delimiters.\n\nIf the given string contains non-ASCII characters, these are first encoded as UTF-8 and then percent encoding is applied separately to each UTF-8 byte.",
    "signature": "urlencode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/urlencode"
  },
  "yamldecode": {
    "description": "`yamldecode` parses a string as a subset of YAML, and produces a representation of its value.\n\nThis function supports a subset of [YAML 1.2](https://yaml.org/spec/1.2/spec.html).",
    "signature": "yamldecode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/yamldecode"
  },
  "yamlencode": {
    "description": "`yamlencode` encodes a given value to a string using [YAML 1.2](https://yaml.org/spec/1.2/spec) block syntax.\n\n~> **Warning:** This function is currently **experimental** and its exact result format may change in future versions of Packer, based on feedback. Do not use `yamldecode` to construct a value for any resource argument where changes to the result would be disruptive. To get a consistent string representation of a value use `jsonencode` instead; its results are also valid YAML because YAML is a JSON superset.",
    "signature": "yamlencode(string)",
    "type": "encoding",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/encoding/yamlencode"
  },
  "abspath": {
    "description": "`abspath` takes a string containing a filesystem path and converts it to an absolute path. That is, if the path is not absolute, it will be joined with the current working directory.\n\nReferring directly to filesystem paths in resource arguments may cause spurious diffs if the same configuration is applied from multiple systems or on different host operating systems. We recommend using filesystem paths only for transient values, such as the argument to `file` (where only the contents are then stored).",
    "signature": "abspath(filesystem_path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/abspath"
  },
  "basename": {
    "description": "`basename` takes a string containing a filesystem path and removes all except the last portion from it.\n\nThis function works only with the path string and does not access the filesystem itself. It is therefore unable to take into account filesystem features such as symlinks.\n\nIf the path is empty then the result is `\".\"`, representing the current working directory.\n\nThe behavior of this function depends on the host platform. On Windows systems, it uses backslash `` as the path segment separator. On Unix systems, the slash `/` is used.\n\nReferring directly to filesystem paths in resource arguments may cause spurious diffs if the same configuration is applied from multiple systems or on different host operating systems. We recommend using filesystem paths only for transient values, such as the argument to `file` (where only the contents are then stored) or in `connection` and `provisioner` blocks.",
    "signature": "basename(filesystem_path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/basename"
  },
  "dirname": {
    "description": "`dirname` takes a string containing a filesystem path and removes the last portion from it.\n\nThis function works only with the path string and does not access the filesystem itself. It is therefore unable to take into account filesystem features such as symlinks.\n\nIf the path is empty then the result is `\".\"`, representing the current working directory.\n\nThe behavior of this function depends on the host platform. On Windows systems, it uses backslash `` as the path segment separator. On Unix systems, the slash `/` is used. The result of this function is normalized, so on a Windows system any slashes in the given path will be replaced by backslashes before returning.\n\nReferring directly to filesystem paths in resource arguments may cause spurious diffs if the same configuration is applied from multiple systems or on different host operating systems. We recommend using filesystem paths only for transient values, such as the argument to `file` (where only the contents are then stored) or in `connection` and `provisioner` blocks.",
    "signature": "dirname(filesystem_path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/dirname"
  },
  "file": {
    "description": "`file` reads the contents of a file at the given path and returns them as a string.\n\nStrings in the Packer language are sequences of Unicode characters, so this function will interpret the file contents as UTF-8 encoded text and return the resulting Unicode characters. If the file contains invalid UTF-8 sequences then this function will produce an error.\n\nThis function can be used only with files that already exist on disk at the beginning of a Packer run. Functions do not participate in the dependency graph, so this function cannot be used with files that are generated dynamically during a Packer operation.",
    "signature": "file(path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/file"
  },
  "fileexists": {
    "description": "`fileexists` determines whether a file exists at a given path.\n\nFunctions are evaluated during configuration parsing rather than at apply time, so this function can only be used with files that are already present on disk before Packer takes any actions.\n\nThis function works only with regular files. If used with a directory, FIFO, or other special mode, it will return an error.",
    "signature": "fileexists(path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/fileexists"
  },
  "fileset": {
    "description": "`fileset` enumerates a set of regular file names given a path and pattern. The path is automatically removed from the resulting set of file names and any result still containing path separators always returns forward slash (`/`) as the path separator for cross-system compatibility.\n\nSupported pattern matches:\n\n- `*` - matches any sequence of non-separator characters\n- `**` - matches any sequence of characters, including separator characters\n- `?` - matches any single non-separator character\n- `{alternative1,...}` - matches a sequence of characters if one of the comma-separated alternatives matches\n- `[CLASS]` - matches any single non-separator character inside a class of characters (see below)\n- `[^CLASS]` - matches any single non-separator character outside a class of characters (see below)\n\nCharacter classes support the following:\n\n- `[abc]` - matches any single character within the set\n- `[a-z]` - matches any single character within the range\n\nFunctions are evaluated during configuration parsing rather than at apply time, so this function can only be used with files that are already present on disk before Packer takes any actions.",
    "signature": "fileset(path, pattern)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/fileset"
  },
  "pathexpand": {
    "description": "`pathexpand` takes a filesystem path that might begin with a `~` segment, and if so it replaces that segment with the current user's home directory path.\n\nThis function works only with the path string and does not access the filesystem itself. It is therefore unable to take into account filesystem features such as symlinks.\n\nIf the leading segment in the path is not `~` then the given path is returned unmodified.\n\nUsing this function in resource arguments will cause spurious diffs if the same configuration is run by multiple users with different home directory paths, or used on different host operating systems. We recommend using this function only for transient values, such as in `connection` and `provisioner` blocks to locate SSH keys, etc.\n\nThe rules for determining the \"home directory\" for the current user vary depending on host operating system.",
    "signature": "pathexpand(path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/pathexpand"
  },
  "templatefile": {
    "description": "`templatefile` reads the file at the given path and renders its content as a template using a supplied set of template variables.\n\nThe template syntax is the same as for string templates in the main HCL2 language, including interpolation sequences delimited with `${ ... }`. This function just allows longer template sequences to be factored out into a separate file for readability.\n\nThe \"vars\" argument must be a map. Within the template file, each of the keys in the map is available as a variable for interpolation. The template may also use any other function available in Packer, except that recursive calls to templatefile are not permitted. Variable names must each start with a letter, followed by zero or more letters, digits, or underscores.\n\nStrings in HCL2 are sequences of Unicode characters, so this function will interpret the file contents as UTF-8 encoded text and return the resulting Unicode characters. If the file contains invalid UTF-8 sequences then this function will produce an error.\n\nThis function can be used only with files that already exist on disk at the beginning of a run.",
    "signature": "templatefile(path)",
    "type": "filesystem",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/file/templatefile"
  },
  "formatdate": {
    "description": "`formatdate` converts a timestamp into a different time format.\n\nIn Packer, timestamps are conventionally represented as strings using [RFC 3339](https://tools.ietf.org/html/rfc3339) \"Date and Time format\" syntax. `formatdate` requires the `timestamp` argument to be a string conforming to this syntax.",
    "signature": "formatdate(spec, timestamp)",
    "type": "date and time",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/datetime/formatdate"
  },
  "timeadd": {
    "description": "`timeadd` adds a duration to a timestamp, returning a new timestamp.\n\nIn the Packer language, timestamps are conventionally represented as strings using [RFC 3339](https://tools.ietf.org/html/rfc3339) \"Date and Time format\" syntax. `timeadd` requires the `timestamp` argument to be a string conforming to this syntax.\n\n`duration` is a string representation of a time difference, consisting of sequences of number and unit pairs, like `\"1.5h\"` or `\"1h30m\"`. The accepted units are `\"ns\"`, `\"us\"` (or `\"Âµs\"`), `\"ms\"`, `\"s\"`, `\"m\"`, and `\"h\"`. The first number may be negative to indicate a negative duration, like `\"-2h5m\"`.\n\nThe result is a string, also in RFC 3339 format, representing the result of adding the given direction to the given timestamp.",
    "signature": "timeadd(timestamp, duration)",
    "type": "date and time",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/datetime/timeadd"
  },
  "timestamp": {
    "description": "`timestamp` returns the current date and time.\n\nIn the Packer language, timestamps are conventionally represented as strings using [RFC 3339](https://tools.ietf.org/html/rfc3339) \"Date and Time format\" syntax, and so `timestamp` returns a string in this format.\n\nThe result of this function will change every second, so using this function directly with resource attributes will cause a diff to be detected on every Packer run.",
    "signature": "timestamp()",
    "type": "date and time",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/datetime/timestamp"
  },
  "legacy_isotime": {
    "description": "The `legacy_isotime` function returns the current date and time using the given format string. The format string follows golang's datetime formatting.\n\nThis function has been provided to create backwards compatibility with Packer's legacy JSON templates. However, we recommend that you upgrade your HCL Packer template to use `timestamp` and `formatdate` together as soon as is convenient.\n\n-> **Note:** If you are using a large number of builders, provisioners or post-processors, the isotime may be slightly different for each one because it is from when the plugin is launched not the initial Packer process. In order to avoid this and make the timestamp consistent across all plugins, set it as a user variable and then access the user variable within your plugins.",
    "signature": "legacy_isotime()",
    "type": "date and time",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/datetime/legacy_isotime"
  },
  "legacy_strftime": {
    "description": "The `legacy_strftime` function returns the current date and time using the given format string. The format string follows strftime's datetime formatting.\n\nThis function has been provided to create backwards compatibility with Packer's legacy JSON templates. However, we recommend that you upgrade your HCL Packer template to use `timestamp` and `formatdate` together as soon as is convenient.\n\n-> **Note:** If you are using a large number of builders, provisioners or post-processors, the strftime may be slightly different for each one because it is from when the plugin is launched not the initial Packer process. In order to avoid this and make the timestamp consistent across all plugins, set it as a user variable and then access the user variable within your plugins.",
    "signature": "legacy_strftime()",
    "type": "date and time",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/datetime/legacy_strftime"
  },
  "bcrypt": {
    "description": "`bcrypt` computes a hash of the given string using the Blowfish cipher, returning a string in [the _Modular Crypt Format_](https://passlib.readthedocs.io/en/stable/modular_crypt_format.html) usually expected in the shadow password file on many Unix systems.\n\nThe `cost` argument is optional and will default to 10 if unspecified.\n\nSince a bcrypt hash value includes a randomly selected salt, each call to this function will return a different value, even if the given string and cost are the same. Using this function directly with resource arguments will therefore cause spurious diffs. We recommend using this function only in `provisioner` or `post-processor` blocks, or in data resources whose results are only used in those blocks.\n\nThe version prefix on the generated string (e.g. `$2a$`) may change in future versions of Packer.",
    "signature": "bcrypt(string, cost)",
    "type": "hash and crypto",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/crypto/bcrypt"
  },
  "md5": {
    "description": "`md5` computes the MD5 hash of a given string and encodes it with hexadecimal digits.\n\nThe given string is first encoded as UTF-8 and then the MD5 algorithm is applied as defined in [RFC 1321](https://tools.ietf.org/html/rfc1321). The raw hash is then encoded to lowercase hexadecimal digits before returning.\n\nBefore using this function for anything security-sensitive, refer to [RFC 6151](https://tools.ietf.org/html/rfc6151) for updated security considerations applying to the MD5 algorithm.",
    "signature": "md5(string)",
    "type": "hash and crypto",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/crypto/md5"
  },
  "rsadecrypt": {
    "description": "`rsadecrypt` decrypts an RSA-encrypted ciphertext, returning the corresponding cleartext.\n\nciphertext` must be a base64-encoded representation of the ciphertext, using the PKCS #1 v1.5 padding scheme. Packer uses the \"standard\" Base64 alphabet as defined in [RFC 4648 section 4](https://tools.ietf.org/html/rfc4648#section-4).\n\n`privatekey` must be a PEM-encoded RSA private key that is not itself encrypted.\n\nPacker has no corresponding function for _encrypting_ a message. Use this function to decrypt ciphertexts returned by remote services using a keypair negotiated out-of-band.",
    "signature": "rsadecrypt(ciphertext, privatekey)",
    "type": "hash and crypto",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/crypto/rsadecrypt"
  },
  "sha1": {
    "description": "`sha1` computes the SHA1 hash of a given string and encodes it with hexadecimal digits.\n\nThe given string is first encoded as UTF-8 and then the SHA1 algorithm is applied as defined in [RFC 3174](https://tools.ietf.org/html/rfc3174). The raw hash is then encoded to lowercase hexadecimal digits before returning.\n\nCollision attacks have been successfully performed against this hashing function. Before using this function for anything security-sensitive, review relevant literature to understand the security implications.",
    "signature": "sha1(string)",
    "type": "hash and crypto",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/crypto/sha1"
  },
  "sha256": {
    "description": "`sha256` computes the SHA256 hash of a given string and encodes it with hexadecimal digits.\n\nThe given string is first encoded as UTF-8 and then the SHA256 algorithm is applied as defined in [RFC 4634](https://tools.ietf.org/html/rfc4634). The raw hash is then encoded to lowercase hexadecimal digits before returning.",
    "signature": "sha256(string)",
    "type": "hash and crypto",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/crypto/sha256"
  },
  "sha512": {
    "description": "`sha512` computes the SHA512 hash of a given string and encodes it with hexadecimal digits.\n\nThe given string is first encoded as UTF-8 and then the SHA512 algorithm is applied as defined in [RFC 4634](https://tools.ietf.org/html/rfc4634). The raw hash is then encoded to lowercase hexadecimal digits before returning.",
    "signature": "sha512(string)",
    "type": "hash and crypto",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/crypto/sha512"
  },
  "uuidv4": {
    "description": "`uuidv4` generates a unique identifier string.\n\nThe id is a generated and formatted as required by [RFC 4122 section 4.4](https://tools.ietf.org/html/rfc4122#section-4.4), producing a Version 4 UUID. The result is a UUID generated only from pseudo-random numbers.\n\nThis function produces a new value each time it is called, and so using it directly in resource arguments will result in spurious diffs. We do not recommend using the `uuidv4` function in resource configurations.",
    "signature": "uuidv4()",
    "type": "uuid",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/uuid/uuidv4"
  },
  "uuidv5": {
    "description": "`uuidv5` generates a _name-based_ UUID, as described in [RFC 4122 section 4.3](https://tools.ietf.org/html/rfc4122#section-4.3), also known as a \"version 5\" UUID.\n\nUnlike the pseudo-random UUIDs generated by `uuidv4`, name-based UUIDs derive from namespace and an name, producing the same UUID value every time if the namespace and name are unchanged.",
    "signature": "uuidv5(namespace, name)",
    "type": "uuid",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/uuid/uuidv5"
  },
  "cidrhost": {
    "description": "`cidrhost` calculates a full host IP address for a given host number within a given IP network address prefix.\n\n`prefix` must be given in CIDR notation, as defined in [RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).\n\n`hostnum` is a whole number that can be represented as a binary integer with no more than the number of digits remaining in the address after the given prefix. For more details on how this function interprets CIDR prefixes and populates host numbers, see the worked example for `cidrsubnet`.\n\nConventionally host number zero is used to represent the address of the network itself and the host number that would fill all the host bits with binary 1 represents the network's broadcast address. These numbers should generally not be used to identify individual hosts except in unusual situations, such as point-to-point links.\n\nThis function accepts both IPv6 and IPv4 prefixes, and the result always uses the same addressing scheme as the given prefix.",
    "signature": "cidrhost(prefix, hostnum)",
    "type": "ip network",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/ipnet/cidrhost"
  },
  "cidrnetmask": {
    "description": "`cidrnetmask` converts an IPv4 address prefix given in CIDR notation into a subnet mask address.\n\n`prefix` must be given in IPv4 CIDR notation, as defined in [RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).\n\nThe result is a subnet address formatted in the conventional dotted-decimal IPv4 address syntax, as expected by some software.\n\nCIDR notation is the only valid notation for IPv6 addresses, so `cidrnetmask` produces an error if given an IPv6 address.",
    "signature": "cidrnetmask(prefix)",
    "type": "ip network",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/ipnet/cidrnetmask"
  },
  "cidrsubnet": {
    "description": "`cidrsubnet` calculates a subnet address within given IP network address prefix.\n\n`prefix` must be given in CIDR notation, as defined in [RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).\n\n`newbits` is the number of additional bits with which to extend the prefix. For example, if given a prefix ending in `/16` and a `newbits` value of `4`, the resulting subnet address will have length `/20`.\n\n`netnum` is a whole number that can be represented as a binary integer with no more than `newbits` binary digits, which will be used to populate the additional bits added to the prefix.\n\nThis function accepts both IPv6 and IPv4 prefixes, and the result always uses the same addressing scheme as the given prefix.\n\nUnlike the related function `cidrsubnets`, `cidrsubnet` allows you to give a specific network number to use. `cidrsubnets` can allocate multiple network addresses at once, but numbers them automatically starting with zero.",
    "signature": "cidrsubnet(prefix, newbits, netnum)",
    "type": "ip network",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/ipnet/cidrsubnet"
  },
  "cidrsubnets": {
    "description": "`cidrsubnets` calculates a sequence of consecutive IP address ranges within a particular CIDR prefix.\n\n`prefix` must be given in CIDR notation, as defined in [RFC 4632 section 3.1](https://tools.ietf.org/html/rfc4632#section-3.1).\n\nThe remaining arguments, indicated as `newbits` above, each specify the number of additional network prefix bits for one returned address range. The return value is therefore a list with one element per `newbits` argument, each a string containing an address range in CIDR notation.\n\nFor more information on IP addressing concepts, see the documentation for the related function `cidrsubnet`. `cidrsubnet` calculates a single subnet address within a prefix while allowing you to specify its subnet number, while `cidrsubnets` can calculate many at once, potentially of different sizes, and assigns subnet numbers automatically.\n\nWhen using this function to partition an address space as part of a network address plan, you must not change any of the existing arguments once network addresses have been assigned to real infrastructure, or else later address assignments will be invalidated. However, you _can_ append new arguments to existing calls safely, as long as there is sufficient address space available.\n\nThis function accepts both IPv6 and IPv4 prefixes, and the result always uses the same addressing scheme as the given prefix.",
    "signature": "cidrsubnets(prefix, newbits...)",
    "type": "ip network",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/ipnet/cidrsubnets"
  },
  "can": {
    "description": "`can` evaluates the given expression and returns a boolean value indicating whether the expression produced a result without any errors.\n\nThis is a special function that is able to catch errors produced when evaluating its argument. For most situations where you could use `can` it's better to use `try` instead, because it allows for more concise definition of fallback values for failing expressions.\n\nThe `can` function can only catch and handle _dynamic_ errors resulting from access to data that isn't known until runtime. It will not catch errors relating to expressions that can be proven to be invalid for any input, such as a malformed resource reference.\n\n~> **Warning:** The `can` function is intended only for simple tests in variable validation rules. Although it can technically accept any sort of expression and be used elsewhere in the configuration, we recommend against using it in other contexts. For error handling elsewhere in the configuration, prefer to use `try`.",
    "signature": "can(expression)",
    "type": "type conversion",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/conversion/can"
  },
  "convert": {
    "description": "`convert` converts a value or an expression to a given type.\n\nExplicit type conversions are rarely necessary in HCL because it will convert types automatically where required. Use the explicit type conversion functions only to normalize types returned in outputs.\n\nOnly numbers and strings containing decimal representations of numbers can be converted to number. All other values will produce an error.\n\nOnly boolean values and the exact strings \"true\" and \"false\" can be converted to boolean. All other values will produce an error.\n\nOnly the primitive types (string, number, and bool) can be converted to string. All other values will produce an error.",
    "signature": "convert(value | expression)",
    "type": "type conversion",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/conversion/convert"
  },
  "try": {
    "description": "`try` evaluates all of its argument expressions in turn and returns the result of the first one that does not produce any errors.\n\nThis is a special function that is able to catch errors produced when evaluating its arguments, which is particularly useful when working with complex data structures whose shape is not well-known at implementation time.\n\nFor example, if some data is retrieved from an external system in JSON or YAML format and then decoded, the result may have attributes that are not guaranteed to be set. We can use `try` to produce a normalized data structure which has a predictable type that can therefore be used more conveniently elsewhere in the configuration.",
    "signature": "try(expressions...)",
    "type": "type conversion",
    "url": "https://www.packer.io/docs/templates/hcl_templates/functions/conversion/try"
  }
}
